"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModuleProviders = void 0;
const core_1 = require("@event-nest/core");
const knex_1 = require("knex");
const schema_configuration_1 = require("./schema-configuration");
const postgresql_event_store_1 = require("./storage/postgresql-event-store");
const table_initializer_1 = require("./table-initializer");
const KNEX_CONNECTION = Symbol("EVENT_NEST_KNEX_CONNECTION");
class ModuleProviders {
    static create(options) {
        return [
            {
                provide: core_1.DomainEventEmitter,
                useFactory: () => {
                    return new core_1.DomainEventEmitter(options.concurrentSubscriptions);
                }
            },
            {
                provide: KNEX_CONNECTION,
                useValue: buildKnexConnection(options)
            },
            {
                inject: [core_1.DomainEventEmitter, KNEX_CONNECTION],
                provide: core_1.EVENT_STORE,
                useFactory: (eventEmitter, knexConnection) => {
                    return new postgresql_event_store_1.PostgreSQLEventStore(eventEmitter, options.schemaName, options.aggregatesTableName, options.eventsTableName, knexConnection);
                }
            },
            {
                inject: [KNEX_CONNECTION],
                provide: table_initializer_1.TableInitializer,
                useFactory: (knexConnection) => {
                    return new table_initializer_1.TableInitializer(new schema_configuration_1.SchemaConfiguration(options.schemaName, options.aggregatesTableName, options.eventsTableName), (0, core_1.isNil)(options.ensureTablesExist) ? false : options.ensureTablesExist, knexConnection);
                }
            }
        ];
    }
    static createAsync(options) {
        const optionsProvider = {
            inject: options.inject,
            provide: "EVENT_NEST_PG_OPTIONS",
            useFactory: async (...parameters) => {
                return await options.useFactory(...parameters);
            }
        };
        const emitterProvider = {
            inject: ["EVENT_NEST_PG_OPTIONS"],
            provide: core_1.DomainEventEmitter,
            useFactory: (options) => {
                return new core_1.DomainEventEmitter(options.concurrentSubscriptions);
            }
        };
        const knexProvider = {
            inject: ["EVENT_NEST_PG_OPTIONS"],
            provide: KNEX_CONNECTION,
            useFactory: (options) => {
                return buildKnexConnection(options);
            }
        };
        const eventStoreProvider = {
            inject: ["EVENT_NEST_PG_OPTIONS", core_1.DomainEventEmitter, KNEX_CONNECTION],
            provide: core_1.EVENT_STORE,
            useFactory: (options, emitter, knexConnection) => {
                return new postgresql_event_store_1.PostgreSQLEventStore(emitter, options.schemaName, options.aggregatesTableName, options.eventsTableName, knexConnection);
            }
        };
        const tableInitializerProvider = {
            inject: [KNEX_CONNECTION, "EVENT_NEST_PG_OPTIONS"],
            provide: table_initializer_1.TableInitializer,
            useFactory: (knexConnection, options) => {
                return new table_initializer_1.TableInitializer(new schema_configuration_1.SchemaConfiguration(options.schemaName, options.aggregatesTableName, options.eventsTableName), (0, core_1.isNil)(options.ensureTablesExist) ? false : options.ensureTablesExist, knexConnection);
            }
        };
        return [optionsProvider, knexProvider, emitterProvider, eventStoreProvider, tableInitializerProvider];
    }
}
exports.ModuleProviders = ModuleProviders;
function buildKnexConnection(options) {
    if ((0, core_1.isNil)(options.ssl)) {
        return (0, knex_1.knex)({
            client: "pg",
            connection: {
                connectionString: options.connectionUri
            }
        });
    }
    return (0, knex_1.knex)({
        client: "pg",
        connection: {
            connectionString: options.connectionUri,
            ssl: {
                ca: options.ssl.certificate,
                rejectUnauthorized: options.ssl.rejectUnauthorized
            }
        }
    });
}
//# sourceMappingURL=module-providers.js.map