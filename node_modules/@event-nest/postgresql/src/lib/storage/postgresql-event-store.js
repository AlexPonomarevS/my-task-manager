"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PostgreSQLEventStore = void 0;
const core_1 = require("@event-nest/core");
const common_1 = require("@nestjs/common");
const node_crypto_1 = require("node:crypto");
const schema_configuration_1 = require("../schema-configuration");
class PostgreSQLEventStore extends core_1.AbstractEventStore {
    constructor(eventEmitter, schemaName, aggregatesTableName, eventsTableName, _knexConnection) {
        super(eventEmitter);
        this._knexConnection = _knexConnection;
        this._logger = new common_1.Logger(PostgreSQLEventStore.name);
        this._schemaConfiguration = new schema_configuration_1.SchemaConfiguration(schemaName, aggregatesTableName, eventsTableName);
    }
    /**
     * @deprecated Use {@link schemaConfiguration} instead
     */
    get aggregatesTableName() {
        return this.schemaConfiguration.aggregatesTable;
    }
    /**
     * @deprecated Use {@link schemaConfiguration} instead
     */
    get eventsTableName() {
        return this.schemaConfiguration.eventsTable;
    }
    get schemaConfiguration() {
        return this._schemaConfiguration;
    }
    /**
     * @deprecated Use {@link schemaConfiguration} instead
     */
    get schemaName() {
        return this.schemaConfiguration.schema;
    }
    async findAggregateRootVersion(id) {
        const aggregate = await this._knexConnection(this._schemaConfiguration.schemaAwareAggregatesTable)
            .select("version")
            .where("id", id)
            .first();
        if ((0, core_1.isNil)(aggregate)) {
            return -1;
        }
        return aggregate.version;
    }
    async findByAggregateRootId(aggregateRootClass, id) {
        const startedAt = Date.now();
        const aggregateRootName = (0, core_1.getAggregateRootName)(aggregateRootClass);
        if ((0, core_1.isNil)(aggregateRootName)) {
            this._logger.error(`Missing aggregate root name for class: ${aggregateRootClass.name}. Use the @AggregateRootName decorator.`);
            throw new core_1.MissingAggregateRootNameException(aggregateRootClass.name);
        }
        const rows = await this._knexConnection(this._schemaConfiguration.schemaAwareEventsTable)
            .select("*")
            .where({
            aggregate_root_id: id,
            aggregate_root_name: aggregateRootName
        });
        const duration = Date.now() - startedAt;
        this._logger.debug(`Finding events for aggregate ${id} took ${duration}ms`);
        if (rows.length > 0) {
            return rows.map((row) => {
                return core_1.StoredEvent.fromStorage(row.id, row.aggregate_root_id, row.event_name, row.created_at, row.aggregate_root_version, row.aggregate_root_name, row.payload);
            });
        }
        return [];
    }
    async findByAggregateRootIds(aggregateRootClass, ids) {
        const aggregateRootName = (0, core_1.getAggregateRootName)(aggregateRootClass);
        if ((0, core_1.isNil)(aggregateRootName)) {
            this._logger.error(`Missing aggregate root name for class: ${aggregateRootClass.name}. Use the @AggregateRootName decorator.`);
            throw new core_1.MissingAggregateRootNameException(aggregateRootClass.name);
        }
        const rows = await this._knexConnection(this._schemaConfiguration.schemaAwareEventsTable)
            .select("*")
            .whereIn("aggregate_root_id", ids)
            .andWhere({
            aggregate_root_name: aggregateRootName
        });
        const grouped = {};
        for (const row of rows) {
            if ((0, core_1.isNil)(grouped[row.aggregate_root_id])) {
                grouped[row.aggregate_root_id] = [];
            }
            grouped[row.aggregate_root_id].push(core_1.StoredEvent.fromStorage(row.id, row.aggregate_root_id, row.event_name, row.created_at, row.aggregate_root_version, row.aggregate_root_name, row.payload));
        }
        return grouped;
    }
    generateEntityId() {
        return Promise.resolve((0, node_crypto_1.randomUUID)());
    }
    async save(events, aggregate) {
        const startedAt = Date.now();
        if (events.length === 0) {
            return [];
        }
        let incrementedVersion = 0;
        let finalAggregate;
        try {
            await this._knexConnection.transaction(async (trx) => {
                const aggregateInDatabase = await trx(this._schemaConfiguration.schemaAwareAggregatesTable)
                    .select("*")
                    .forUpdate()
                    .where("id", aggregate.id)
                    .first();
                let foundAggregate = (0, core_1.isNil)(aggregateInDatabase)
                    ? undefined
                    : new core_1.StoredAggregateRoot(aggregateInDatabase.id, aggregateInDatabase.version);
                if ((0, core_1.isNil)(foundAggregate)) {
                    aggregate.version = 0;
                    this._logger.debug(`Aggregate ${aggregate.id} does not exist. Will save it`);
                    await trx(this._schemaConfiguration.schemaAwareAggregatesTable).insert({
                        id: aggregate.id,
                        version: aggregate.version
                    });
                    foundAggregate = aggregate;
                }
                if (aggregate.isOutdated(foundAggregate)) {
                    this._logger.error(`Version conflict detected for aggregate ${aggregate.id}. Expected ${aggregate.version}. Stored ${foundAggregate.version}`);
                    throw new core_1.EventConcurrencyException(aggregate.id, foundAggregate.version, aggregate.version);
                }
                for (const [index, storedEvent] of events.entries()) {
                    incrementedVersion = aggregate.version + index + 1;
                    storedEvent.aggregateRootVersion = incrementedVersion;
                }
                aggregate.version = incrementedVersion;
                finalAggregate = aggregate;
                this._logger.debug(`Saving ${events.length} events for aggregate ${aggregate.id}`);
                const mapped = events.map((storedEvent) => {
                    return {
                        aggregate_root_id: storedEvent.aggregateRootId,
                        aggregate_root_name: storedEvent.aggregateRootName,
                        aggregate_root_version: storedEvent.aggregateRootVersion,
                        created_at: storedEvent.createdAt,
                        event_name: storedEvent.eventName,
                        id: storedEvent.id,
                        payload: JSON.stringify(storedEvent.payload)
                    };
                });
                await trx(this._schemaConfiguration.schemaAwareEventsTable).insert(mapped);
                await trx(this._schemaConfiguration.schemaAwareAggregatesTable)
                    .update("version", finalAggregate.version)
                    .where("id", finalAggregate.id);
            });
        }
        catch (error) {
            this._logger.error("Unable to complete transaction for aggregate root with id : " + aggregate.id);
            throw error;
        }
        const duration = Date.now() - startedAt;
        this._logger.debug(`Saving events for aggregate ${aggregate.id} took ${duration}ms`);
        return events;
    }
}
exports.PostgreSQLEventStore = PostgreSQLEventStore;
//# sourceMappingURL=postgresql-event-store.js.map