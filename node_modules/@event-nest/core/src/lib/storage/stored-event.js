"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StoredEvent = void 0;
const class_transformer_1 = require("class-transformer");
const domain_event_registrations_1 = require("../domain-event-registrations");
const type_utils_1 = require("../utils/type-utils");
/**
 * Represents an event that will be persisted according to the storage solution that is used.
 * The event is defined by metadata like aggregate root id, version and creation date, and it also includes its payload
 * which can be any object based on the use case. Payload serialization is done using class-transformer
 * (https://github.com/typestack/class-transformer) so the payload needs to follow the rules defined by that library.
 *
 * The class constructor is marked as private to force the use of the static factory methods which are implemented based
 * on the use case to create the event.
 *
 */
class StoredEvent {
    constructor(id, aggregateRootId) {
        this._aggregateRootId = aggregateRootId;
        this._id = id;
    }
    /**
     * Factory method that will create a new event based on the provided info. Typically, it should be used when
     * creating a new event that will be persisted. In this case, the payload is serialized to a plain object using the
     * class-transformer library.
     * @param id The event id
     * @param aggregateRootId The aggregate root id
     * @param aggregateRootName The name of the aggregate root
     * @param payload The event payload as an object.
     * @param occurredAt The event creation date
     */
    static fromPublishedEvent(id, aggregateRootId, aggregateRootName, payload, occurredAt) {
        const newEvent = new StoredEvent(id, aggregateRootId);
        newEvent._createdAt = occurredAt;
        newEvent._aggregateRootName = aggregateRootName;
        const eventName = (0, domain_event_registrations_1.getEventName)(payload);
        if (!(0, type_utils_1.isNil)(eventName)) {
            newEvent._payload = (0, class_transformer_1.instanceToPlain)(payload);
            newEvent._eventName = eventName;
        }
        return newEvent;
    }
    /**
     * Factory method that will create a new event based on the provided info. Typically, it should be used when creating
     * an event that is already persisted, and we want to create a new instance of it to pass it to an aggregate root.
     * In this case the payload is not mapped to a class instance. {@link getPayloadAs} should be later used for this
     * kind of mapping.
     *
     * @param id The event id
     * @param aggregateRootId The aggregate root id
     * @param eventName The event name
     * @param createdAt The event creation date
     * @param aggregateRootVersion The aggregate root version
     * @param aggregateRootName The aggregate root name
     * @param payload The event payload as an object.
     */
    static fromStorage(id, aggregateRootId, eventName, createdAt, aggregateRootVersion, aggregateRootName, payload) {
        const newEvent = new StoredEvent(id, aggregateRootId);
        newEvent._eventName = eventName;
        newEvent._createdAt = createdAt;
        newEvent.aggregateRootVersion = aggregateRootVersion;
        newEvent._aggregateRootName = aggregateRootName;
        newEvent._payload = payload;
        return newEvent;
    }
    get aggregateRootId() {
        return this._aggregateRootId;
    }
    get aggregateRootName() {
        return this._aggregateRootName;
    }
    get createdAt() {
        return this._createdAt;
    }
    get eventName() {
        return this._eventName;
    }
    get id() {
        return this._id;
    }
    get payload() {
        return this._payload;
    }
    getPayloadAs(payloadClass) {
        return (0, class_transformer_1.plainToClass)(payloadClass, this._payload);
    }
}
exports.StoredEvent = StoredEvent;
//# sourceMappingURL=stored-event.js.map