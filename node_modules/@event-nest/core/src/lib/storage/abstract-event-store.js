"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractEventStore = void 0;
const aggregate_root_name_1 = require("../aggregate-root/aggregate-root-name");
const id_generation_exception_1 = require("../exceptions/id-generation-exception");
const missing_aggregate_root_name_exception_1 = require("../exceptions/missing-aggregate-root-name-exception");
const unknown_event_version_exception_1 = require("../exceptions/unknown-event-version-exception");
const type_utils_1 = require("../utils/type-utils");
const stored_aggregate_root_1 = require("./stored-aggregate-root");
const stored_event_1 = require("./stored-event");
/**
 * An abstract implementation of the {@link EventStore} interface.
 * Regardless of the database technology, all subclasses should have a common implementation
 * of the {@link EventStore:addPublisher} method and this is why this class exists.
 */
class AbstractEventStore {
    constructor(_eventEmitter) {
        this._eventEmitter = _eventEmitter;
    }
    addPublisher(aggregateRoot) {
        aggregateRoot.publish = async (events) => {
            const aggregateRootName = (0, aggregate_root_name_1.getAggregateRootName)(aggregateRoot.constructor);
            if ((0, type_utils_1.isNil)(aggregateRootName)) {
                throw new missing_aggregate_root_name_exception_1.MissingAggregateRootNameException(aggregateRoot.constructor.name);
            }
            if (events.length === 0) {
                return [];
            }
            const ids = await Promise.all(events.map(() => this.generateEntityId()));
            if (ids.length !== events.length || !(0, type_utils_1.hasAllValues)(ids)) {
                throw new id_generation_exception_1.IdGenerationException(ids.length, events.length);
            }
            const published = [];
            const storedEvents = [];
            for (const event of events) {
                const id = ids.pop();
                storedEvents.push(stored_event_1.StoredEvent.fromPublishedEvent(id, aggregateRoot.id, aggregateRootName, event.payload, event.occurredAt));
                published.push({
                    ...event,
                    eventId: id,
                    version: aggregateRoot.version
                });
            }
            const toStore = new stored_aggregate_root_1.StoredAggregateRoot(aggregateRoot.id, aggregateRoot.version);
            const saved = await this.save(storedEvents, toStore);
            for (const publishedEvent of published) {
                const found = saved.find((s) => s.id === publishedEvent.eventId);
                if ((0, type_utils_1.isNil)(found)) {
                    throw new unknown_event_version_exception_1.UnknownEventVersionException(publishedEvent.eventId, publishedEvent.aggregateRootId);
                }
                publishedEvent.version = found.aggregateRootVersion;
            }
            this._eventEmitter.emitMultiple(published);
            aggregateRoot.resolveVersion(saved);
            return saved;
        };
        return aggregateRoot;
    }
}
exports.AbstractEventStore = AbstractEventStore;
//# sourceMappingURL=abstract-event-store.js.map