"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DomainEventEmitter = void 0;
const common_1 = require("@nestjs/common");
const rxjs_1 = require("rxjs");
const domain_event_subscription_1 = require("./domain-event-subscription");
const type_utils_1 = require("./utils/type-utils");
class DomainEventEmitter {
    constructor(_concurrentSubscriptions = false) {
        this._concurrentSubscriptions = _concurrentSubscriptions;
        this._handlers = new Map();
        this._logger = new common_1.Logger(DomainEventEmitter.name);
    }
    get concurrentSubscriptions() {
        return this._concurrentSubscriptions;
    }
    bindSubscriptions(injectorModules) {
        injectorModules.forEach((module) => {
            module.providers.forEach((provider) => {
                if (!provider.instance || !provider.instance.constructor) {
                    return;
                }
                if ((0, domain_event_subscription_1.isDomainEventSubscription)(provider.instance)) {
                    const events = (0, domain_event_subscription_1.getEventsFromDomainEventSubscription)(provider.instance);
                    events.forEach((event) => {
                        const eventId = (0, domain_event_subscription_1.getEventId)(event);
                        if (!this._handlers.has(eventId)) {
                            this._handlers.set(eventId, []);
                        }
                        this._logger.debug(`Binding ${provider.instance?.constructor.name} to event ${eventId}`);
                        this._handlers.get(eventId)?.push(provider.instance);
                    });
                }
            });
        });
    }
    emit(withAggregate) {
        if (this._handlers.size === 0) {
            this._logger.warn(`Event ${withAggregate.payload.constructor.name} can't be passed to subscriptions. Make sure you use the @DomainEventSubscription decorator`);
            return Promise.resolve();
        }
        const eventId = (0, domain_event_subscription_1.getEventId)(withAggregate.payload.constructor);
        if ((0, type_utils_1.isNil)(eventId) || !this._handlers.has(eventId)) {
            this._logger.warn(`Event ${withAggregate.payload.constructor.name} can't be passed to subscriptions. Make sure you use the @DomainEventSubscription decorator`);
            return Promise.resolve();
        }
        const handlers = this._handlers.get(eventId);
        const withErrorHandling = handlers.map((handler) => {
            return async () => {
                try {
                    return await handler.onDomainEvent(withAggregate);
                }
                catch (error) {
                    this._logger.error(`Error while emitting event ${withAggregate.payload.constructor.name} : ${error.message}`);
                    throw error;
                }
            };
        });
        return Promise.all(withErrorHandling.map((f) => f()));
    }
    emitMultiple(withAggregate) {
        if (this._concurrentSubscriptions) {
            return Promise.all(withAggregate.map((aggregate) => this.emit(aggregate)));
        }
        return (0, rxjs_1.lastValueFrom)((0, rxjs_1.from)(withAggregate).pipe((0, rxjs_1.concatMap)((event) => (0, rxjs_1.from)(this.emit(event))), (0, rxjs_1.toArray)())).catch((error) => {
            this._logger.debug(`Error while emitting events sequentially: ${error.message}`);
        });
    }
    onModuleDestroy() {
        this._handlers.clear();
    }
}
exports.DomainEventEmitter = DomainEventEmitter;
//# sourceMappingURL=domain-event-emitter.js.map