"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AggregateRoot = void 0;
const common_1 = require("@nestjs/common");
const domain_event_registrations_1 = require("../domain-event-registrations");
const unknown_event_exception_1 = require("../exceptions/unknown-event-exception");
const unregistered_event_exception_1 = require("../exceptions/unregistered-event-exception");
const type_utils_1 = require("../utils/type-utils");
const reflection_1 = require("./reflection");
class AggregateRoot {
    constructor(_id, logger) {
        this._id = _id;
        this._appendedEvents = [];
        this._version = 0;
        this._logger = (0, type_utils_1.isNil)(logger) ? new common_1.Logger(AggregateRoot.name) : logger;
    }
    /**
     * Returns a clone array of all the currently appended events of the entity.
     */
    get appendedEvents() {
        return [...this._appendedEvents];
    }
    get id() {
        return this._id;
    }
    get logger() {
        return this._logger;
    }
    /**
     * Defines the current version of the aggregate root. The version is increased
     * each time an event is persisted.
     */
    get version() {
        return this._version;
    }
    /**
     * Adds an event to the currently existing events of the entity. This will not publish the event. Use the {@link commit}
     * method once all the events you want are appended.
     * @param event The event to be appended
     */
    append(event) {
        if (!(0, domain_event_registrations_1.isRegistered)(event)) {
            this.logger.error(`Event ${event.constructor.name} is not registered.`);
            throw new unregistered_event_exception_1.UnregisteredEventException(event.constructor.name);
        }
        this._appendedEvents.push({
            aggregateRootId: this.id,
            occurredAt: new Date(Date.now()),
            payload: event
        });
    }
    /**
     * All the events that have been previously appended will be committed once this method runs. After publishing,
     * the appended events will be deleted so that the next commit publishes newer events.
     * During publishing, the events will be saved and after the successful save, all the application event
     * handlers will be called to take care of async updates.
     * Call this once all the events you want, have been appended.
     */
    async commit() {
        const toPublish = [...this._appendedEvents];
        if (toPublish.length > 0) {
            await this.publish(toPublish);
            this._appendedEvents = [];
            return this;
        }
        return this;
    }
    /**
     * Publishes all the provided events using a connected event publisher. To connect a publisher, use the
     * {@link EventStore}. Normally this should never be called by application logic. Instead, after you append the
     * events, you should call the commit method which will end up calling this method.
     *
     * If a publisher is not connected, the method will return a rejected promise.
     * @param events The events to be published
     */
    publish(events) {
        this.logger.error("There is no event publisher assigned");
        return Promise.reject("There is no event publisher assigned");
    }
    /**
     * Used when a set of events have been retrieved from the database. These events can be passed to the method and the
     * method will trigger all the matching {@link ApplyEvent} functions of the entity to populate the object based on
     * application logic.
     * @param events The events that will be sent to {@link ApplyEvent} functions
     */
    reconstitute(events) {
        const startedAt = Date.now();
        if (events.length > 0) {
            const [unregistered, missingProcessor, known] = this.splitEvents(this.sortEvents(events));
            if (unregistered.length > 0 || missingProcessor.length > 0) {
                const throwable = new unknown_event_exception_1.UnknownEventException(unregistered, missingProcessor, this.id);
                this.logger.error(throwable.message);
                throw throwable;
            }
            for (const knownEvent of known) {
                try {
                    this[knownEvent.processorKey](knownEvent.payload);
                }
                catch (error) {
                    this.logger.error(`Unable to process domain event due to error in processor function: ${error}`);
                    throw error;
                }
            }
            this.resolveVersion(events);
        }
        const duration = Date.now() - startedAt;
        this._logger.debug(`Reconstitution of ${this.constructor.name} took ${duration}ms`);
    }
    resolveVersion(events) {
        const sorted = events.sort((event1, event2) => event1.aggregateRootVersion - event2.aggregateRootVersion);
        const lastElement = sorted.at(-1);
        this._version = (0, type_utils_1.isNil)(lastElement) ? 0 : lastElement.aggregateRootVersion;
    }
    sortEvents(events) {
        return events.sort((event1, event2) => event1.aggregateRootVersion - event2.aggregateRootVersion);
    }
    splitEvents(events) {
        const known = [];
        const unregistered = [];
        const missingProcessor = [];
        for (const storedEvent of events) {
            const eventClass = (0, domain_event_registrations_1.getEventClass)(storedEvent.eventName);
            if ((0, type_utils_1.isNil)(eventClass)) {
                unregistered.push(storedEvent.eventName);
            }
            else {
                const processorKey = (0, reflection_1.getDecoratedPropertyKey)(this, eventClass);
                if ((0, type_utils_1.isNil)(processorKey)) {
                    missingProcessor.push(storedEvent.eventName);
                }
                else {
                    known.push({
                        payload: storedEvent.getPayloadAs(eventClass),
                        processorKey
                    });
                }
            }
        }
        return [unregistered, missingProcessor, known];
    }
}
exports.AggregateRoot = AggregateRoot;
//# sourceMappingURL=aggregate-root.js.map